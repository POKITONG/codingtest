package backjoon.no2292;

import java.util.Scanner;

public class No2292V1 {
    // 입력: 첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.
    // 출력: 입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.

    // 벌집 형성 규칙
    // 중앙에서 시작. 중앙 1.
    // 2는 밑으로 내려가서 오른쪽으로 한바퀴 돔.
    // 중앙은 1이고 주변은 6개가 있으니 7부터 다시 밑으로 내려가서 돔.
    // 처음은 중앙 1. 주변 7. 그 다음은 중앙 8. 주변 19. 그 다음은 중앙 20. 주변 37
    // 이웃하고 있다.

    // 무조건 1부터 시작, 1 다음 한번에 갈 수 있는 숫자는 7까지.
    // 한 번에 갈 수 있는 숫자

    // 1 주변의 배열이 있다고 생각하면, 해당 숫자까지 갈 수 있는 길을 알 수 있다.

    // 해당 배열이 들어있는 숫자가 몇 번째 라운드 줄이냐에 따라서 숫자값이 나뉨
    // 13의 경우 3번째 배열에 있으니 1 + 3 = 4.
    // 58의 경우 4번째 배열(줄)에 있으니 1 + 4 = 5.


    // 1. 7. 19. 37. 61
    // 0 -> 1 6개 증가. 1 -> 2 12개 증가. 2 -> 3 18개 증가. 3 -> 4 24개 증가.
    // 6씩 증가함.

    // 1, 6 + 1, 6 + 6 + 6 + 1, 6 + 6 + 6 + 6 + 6 + 6 + 1,
    // 1, 6 + 1, 6 * 3 + 1, 6 * 6 + 1, 6 * 10 + 1
    // 1, 2부터 7까지 6개, 8부터 19까지 12개, 20부터 37까지 18개, 38부터 61까지 24개
    // size = 1 6 12 18 24 30 36 ...

    // 등차수열 공식
    // 방의 개수는 6 * n
    // n(2a + (n-1)d) / 2
    // n(2 + (n-1)(n*6)) / 2



    // 6 * (1 + 2 + 3 + ... n + 1)
    // 1 + 6 * (n-1)

    // 1 + 3 * n * (n-1)

    // 1 / 1 23 456 78910 1112131415

    // n / 6 == 0 이면 1
    // == 1 이면 2
    // == 2,3 이면 3
    // == 4,5,6 이면 4
    // == 7,8,9,10 이면 5
    // == 11,12,13,14,15 이면 6 ...
    // 근데 내가 이걸 166666까지 만들 순 없어

    // 1 7 19 37 61
    //



    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // N 값 받기

        int N = scanner.nextInt(); // 10억이하니까 int

        // int result = N * ((2 * 7) + (N-1) * (N*6)) / 2;
        //
        int result = 1 + 6 * (N * (N + 1) / 2);

        System.out.println(result);


    }
}
